/**
   Name:       Line Following Robot
   Group:      Group 32
   Authors:    Michael Treffers, Maurice Willemsen
   Version:    1.0
*/

#include <ros.h>
#include <geometry_msgs/Twist.h>

//// All pins for motor driving
const byte trigPin = 23;
const byte echoPin = 22;
const byte en[2] = {24, 25};
const byte rev[2] = {7, 3};
const byte fwd[2] = {6, 2};

//// Shared data for the distance checking
volatile unsigned long dist;
volatile boolean obstacle;

/// Let ROS use the bluetooth module to communicate
class NewHardware :
  public ArduinoHardware {
  public:
    NewHardware():
      ArduinoHardware(&Serial1, 57600) {
    };
};

//// Converts the ros message to a motor command
void convert_ros(float lin, float ang) {
  // ang and lin should be between 0 and 2, min and max are to be sure s1 and s2 are betwoon 0 and 255.
  byte s1 = max(0, min(255, 120 + 30 * lin - 30 * ang)); 
  byte s2 = max(0, min(255, 120 + 30 * lin + 30 * ang)); 
  //log("s1", String(s1));
  //log("s2", String(s2));
  drive(0, s1);
  drive(1, s2);
}

//// The called function when receiving a ROS message
void roscommand( const geometry_msgs::Twist& toggle_msg) {
  //// Set the timer that checks the message timout to 0
  TCNT1 = 0;
  
  //// Log the message info
  float lin = toggle_msg.linear.x;
  float ang = toggle_msg.angular.z;
  //log ("ROS MSG Linear", String(lin, 2));
  //log ("ROS MSG Angular", String(ang, 2));
  
  //// If no obstacle flag is given. map the ros commands to the motor driving.
  if (!obstacle) {
    convert_ros(lin, ang);
  }
}

//// The ROS Classes needed.
ros::NodeHandle_ <NewHardware > nh ;
ros::Subscriber<geometry_msgs::Twist> sub("cmd_vel", &roscommand );

/// Setup when robot starts
void setup() {
  //// Starting the logging
  Serial.begin(57600);
  log ("Robot", "Starting...");

  //// Settings the pinmodes
  pinMode(trigPin, OUTPUT);
  pinMode(echoPin, INPUT);
  pinMode(en[0], OUTPUT);
  pinMode(en[1], OUTPUT);
  pinMode(rev[0], OUTPUT);
  pinMode(rev[1], OUTPUT);
  pinMode(fwd[0], OUTPUT);
  pinMode(fwd[1], OUTPUT);
  pinMode(13, OUTPUT);

  //// Setting the motor enabling and the distance flag off.
  digitalWrite(en[0], LOW);
  digitalWrite(en[1], LOW);
  obstacle = false;

  //// Starting the ROS Node
  nh.initNode();
  nh.subscribe(sub);

  //// Setting all the Timer registers
  noInterrupts();
  TCCR1B = _BV(WGM12) | _BV(CS12) | _BV(CS10);
  TCCR1A = 0;
  OCR1A =  35625;
  TCNT1  = 0;
  TIMSK1 = _BV(OCIE1A);
  TCCR3A = _BV(COM3C1) | _BV(COM3B1) | _BV(WGM30);
  TCCR3B = _BV(WGM32) | _BV(CS32);
  OCR3B = 0;
  OCR3C = 0;
  TCCR4A = _BV(COM4A1) | _BV(COM4B1) | _BV(WGM40);
  TCCR4B = _BV(WGM42) | _BV(CS42);
  OCR4A = 0;
  OCR4B = 0;  
  TCCR5B = _BV(WGM52) | _BV(CS51) | _BV(CS50);
  TCCR5A = 0;
  OCR5A =  50000;
  TCNT5  = 0;
  TIMSK5 = _BV(OCIE5A);
  interrupts();  
}

//// The continious system loop 
void loop() {
  //// Check ROS messages continously
  nh.spinOnce();
}

//// The interrupt function for the distance checking
ISR(TIMER5_COMPA_vect)
{
  //// Check and log distance
  distance();
  log("Distance", String(dist));
  
  //// Check if distance is beneath limit of 10 (0 is given when no distance is measured so the obstacle is assumed to be far enough)
  if (dist > 0 && dist < 10) {
    //// Stop driving and set obstacle flag
    log("Detection", "Stop Driving");
    drive(0, 120);
    drive(1, 120);
    obstacle = true;
  }
  else {
    //// Clear obstacle flag
    obstacle = false;
  }
  digitalWrite(13,obstacle);
}

//// The interrupt called when a message timeout is given
ISR(TIMER1_COMPA_vect)
{
  //// Stop driving
  log("Timeout", "Stop Driving");
  drive(0, 120);
  drive(1, 120);
}

//// The distance checking function
void distance() {
  //// Sends a pulse and waits for receiving the same pulse. The time is then converted to the distance
  digitalWrite(trigPin, LOW);
  delayMicroseconds(2);
  digitalWrite(trigPin, HIGH);
  delayMicroseconds(10);
  digitalWrite(trigPin, LOW);
  dist = (pulseIn(echoPin, HIGH, 20000) / 2) / 29.1;
}

//// Logging 
void log(String type, String msg) { 
  Serial.print(type);
  Serial.print(':');
  Serial.print('\t');
  Serial.print(msg);
  Serial.print('\n');  
}

//// Function called after every loop function, Checks for serial commands
void serialEvent() {
  if (Serial.available()) {
    char data = Serial.read();
    //// Log the command back and convert to motor commands
    log ("Serial Command", String(data));    
    convert_serial(data);
  }
}

void convert_serial(char data) {
  switch (data) {
    case   'W':
      log ("Driving", "Forward");
      drive(0, 255);
      drive(1, 255);
      break;
    case   'A':
      log ("Driving", "Left");
      drive(0, 120);
      drive(1, 255);
      break;
    case   'D':
      log ("Driving", "Right");
      drive(0, 255);
      drive(1, 120);
      break;
    case   'S':
      log ("Driving", "Backward");
      drive(0, 0);
      drive(1, 0);
      break;
    case   'X':
      log ("Driving", "Stop");
      drive(0, 120);
      drive(1, 120);
      break;
  }
}



//// Convert the motor commands to a PWM output
void drive(boolean motor, byte speed) {
  //120 = neutral, <120 = reverse, >120 = forward
  if (speed > 120) {
    digitalWrite(en[motor], HIGH);
    motorpwm(fwd[motor], (speed - 120) * 2);
    motorpwm(rev[motor], 0);
  }
  else if (speed < 120) {
    digitalWrite(en[motor], HIGH);
    motorpwm(rev[motor], (120 - speed) * 2);
    motorpwm(fwd[motor], 0);
  }
  else {
    digitalWrite(en[motor], LOW);
  }
}

//// Set the PWM given with a motor command
void motorpwm(byte pin, byte duty) {
  //log("Motor", String(pin));
  //log("Duty", String(duty));
  switch (pin) {
    case 2:
      OCR3B = duty;
      break;
    case 6:
      OCR4A = duty;
      break;
    case 3:
      OCR3C = duty;
      break;
    case 7:
      OCR4B = duty;
      break;
  }
}

























